<h1> ⭐️ Pentesting Web⭐️ </h1>

<h2> Basic HTTP AUTH </h2>

![http_authentication](https://user-images.githubusercontent.com/63270579/137573003-0b8f63f5-b502-4782-b516-71c6457a90da.png)

<h2> POST request </h2>

<p> The main difference between POST requests and GET requests is that POST requests are not passed with the URL and cannot simply be appended after a ? symbol. POST requests are passed in the data field within the HTTP request.<p>
  
<p>In PHP, "POST" data "content-type" can only accept "application/x-www-form-urlencoded". So, we can set that in "ffuf" with "-H 'Content-Type: application/x-www-form-urlencoded'".</p>  

<p>  Content-Type header is set to application/x-www-form-urlencoded, which is the media type for URL encoded form data.</p>

<h2> CURL </h2>

<p> 
Query strings

Se separan por & y comienzan con ? por ejemplo:

http://209.97.132.64:30193/flag.php?num1=668&num2=669</p>

```bash

curl -u "admin:password" 'http://209.97.132.64:30193/flag.php?num1=668&num2=669' # para Basic Auth login 

```
```bash 
curl -L http://admin:password@ejemploweb.com/ -vvv #	cURL Basic Auth login -L para follow redirect 302 code

```




```bash
curl http://sub.domain.local:PORT/users/admin.php -X POST -d 'id=key' -H 'Content-Type: application/x-www-form-urlencoded'# recordar que en php post envia asi la informacion application/x-www-form-urlencoded
```


<h2> Fuzzing </h2>

```bash
ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ # Basic Scan 
``` 

```bash
ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ # Basic Scan 
``` 

<h3> Extenciones </h3>

<p> Deacuerdo al tipo de servidor se podrian intuir extenciones por ejemplo si es apache, entonces puede ser .php, o si es IIS, entonces podría ser .asp o .aspx.</p>

```bash
ffuf -w /opt/useful/SecLists/Discovery/Web-Content/web-extensions.txt:FUZZ -u http://SERVER_IP:PORT/indexFUZZ #Buscamos la extencion de index 
```

```bash 
ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ -recursion -recursion-depth 1 -e .php -v #Escaneo recursivo con extencion php podemos poner las extenciones que queramos ejemplo -e .php,.html.js etc!
```
<h2> Virtual hosting Fuzzing </h2>

<p> Cuando ingresamos a una direccion IP se revisa primero el archivo /etc/hosts/ si no se encuentra ahi como resolver el dominio se consultan DNS publicos como el de google es por eso que cuando encontramos un dominio se agrega al /etc/hosts </p>

<h3> Subdomains </h2>

```bash
ffuf -w /opt/useful/SecLists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u https://FUZZ.paginapricipal.com/ #Basico para buscar subdominios
```

```bash
ffuf -w /opt/useful/SecLists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u https://FUZZ.paginapricipal.com/ #Basico para buscar subdominios
```

<h3>V Host </h3>

<p> La diferencia clave entre VHosts y subdominios es que un VHost es básicamente un 'subdominio' servido en el mismo servidor y tiene la misma IP, de modo que una sola IP podría servir a dos o más sitios web diferentes.
Una vez más, si usamos el fuzzing de subdominios, solo podríamos identificar subdominios públicos, pero no identificaremos ningún subdominio que no sea público.
</p>

```bash
ffuf -w /opt/useful/SecLists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u http://academy.htb:PORT/ -H 'Host: FUZZ.academy.htb'#Para escanear en busca de VHosts, sin agregar manualmente la lista de palabras completa a nuestro / etc / hosts, estaremos fuzzeando los encabezados HTTP, específicamente el encabezado Host :. Para hacer eso, podemos usar la bandera -H para especificar un encabezado y usaremos la palabra clave FUZZ dentro de él.
```

<h2> Fuzzeo de Parametros POST y GET </h2>

```bash
ffuf -w /opt/useful/SecLists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u http://sub.maindomain.local:PORT/users/admin.php?FUZZ=key -fs #fs sirve para filtrar la respuesta en base a su tamaño
```
<p> Recuerda que tienes que encontrar parametros validos</p>

```bash
 ffuf -w /opt/useful/SecLists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u http://sub.maindomain.local:PORT/users/admin.php -X POST -d 'FUZZ=key' -H 'Content-Type: application/x-www-form-urlencoded' -fs 793 # para encontrar un parametro valido de POST 
 ```
 <p> Despues buscar un valor </p>
 
 ```bash
ffuf -w idslist.txt:FUZZ  -u http://sub.maindomain.local:PORT/users/admin.php  -X POST -d 'id=FUZZ' -H 'Content-Type: application/x-www-form-urlencoded' -fs # para fuzzear un valor en un parametro valido 
 ```
 
<h3> HTTP VS HTTPS SSL y TLS </h3>

<p> Aunque es HTTP en su base, HTTPS utiliza los puertos 443 y 8443 en lugar del puerto estándar 80. Esta es una forma sencilla para que el cliente le indique al servidor que desea establecer una conexión segura. Veamos una salida de tráfico HTTPS y veamos cómo funciona un protocolo de enlace TLS durante un minuto.</p>}
<h3> URL Encode </h3>

<p> It is essential to ensure that our request data is URL-encoded and our request headers are correctly set. Otherwise, we may get a server error in the response. This is why encoding and decoding data becomes essential as we modify and repeat web requests. Some of the key characters we need to encode are:</p>

<p>Spaces: May indicate the end of request data if not encoded</p>
<p>&: Otherwise interpreted as a parameter delimiter            </p>
<p>#: Otherwise interpreted as a fragment identifier            </p>

<h3> The following are some of the other types of encoders </h3>

<p>HTML   </p> 
<p>Unicode</p>
<p>Base64   </p> 
<p>ASCII hex</p> 
