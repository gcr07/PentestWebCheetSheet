<h1> ⭐️ Pentesting Web⭐️ </h1>

<h2> Basic HTTP AUTH </h2>

![http_authentication](https://user-images.githubusercontent.com/63270579/137573003-0b8f63f5-b502-4782-b516-71c6457a90da.png)

<h2> POST request </h2>

<p> The main difference between POST requests and GET requests is that POST requests are not passed with the URL and cannot simply be appended after a ? symbol. POST requests are passed in the data field within the HTTP request.<p>
  
<p>In PHP, "POST" data "content-type" can only accept "application/x-www-form-urlencoded". So, we can set that in "ffuf" with "-H 'Content-Type: application/x-www-form-urlencoded'".</p>  

<p>  Content-Type header is set to application/x-www-form-urlencoded, which is the media type for URL encoded form data.</p>

<p>  The Location header signifies the page we're being redirected to.  </p>

<p> 
The Content-Type header should be changed to application/json for the server to parse it as JSON.</p>

<h2> CURL </h2>

<p> 
  <strong> Query strings </strong>

Se separan por & y comienzan con ? por ejemplo:

http://209.97.132.64:30193/flag.php?num1=668&num2=669</p>

```bash

curl -u "admin:password" 'http://209.97.132.64:30193/flag.php?num1=668&num2=669' # para Basic Auth login 

```

```bash 
curl -L http://admin:password@ejemploweb.com/ -vvv #	cURL Basic Auth login -L para follow redirect 302 code

```

```bash

curl http://64.227.38.214:32608 -X OPTIONS -vv --proxy http://127.0.0.1:8080 #Metodo POST pasar por el proxy de burp para ver todo bonito

```


```bash
curl http://sub.domain.local:PORT/users/admin.php -X POST -d 'id=key' -H 'Content-Type: application/x-www-form-urlencoded'# recordar que en php post envia asi la informacion application/x-www-form-urlencoded
```


```bash

curl -u admin:password  http://example.com/ -vvv # basic Auth

curl -u admin:password -L http://example.com/ # Redirect -L 

curl -d 'username=admin&password=password' -L http://example.com/login.php # when use -d automatly -X POST
 ```

<p> 
The "--cookie" or "--cookie-jar" option can be used to specify cookie usage in cURL. This can point to /dev/null or a file on the disk, where the cookies will be saved.
</p>

```bash
curl -d 'username=admin&password=password' -L --cookie-jar /dev/null  http://example.com/login.php -v # Para que si hay redirect guarde la cookie 

```

<p> Specifying a file name as the argument saves the cookies to a file, which can be used to access the page later directly.</p>

```bash
curl -d 'username=admin&password=password' -L --cookie-jar cookies.txt  http://example.com/login.php #guardar la cookie

#Pass a file with a cookie

curl --cookie cookies.txt http://example.com/admin/dashboard.php -v

```

<p> It's also possible to send JSON data using cURL. This can be done by specifying the "application/json" header with the "-H" flag.</p> 


```bash
curl -H 'Content-Type: application/json' -d '{ "username" : "admin", "password" : "password" }' --cookie-jar /dev/null -L  http://example.com/login.php # enviar datos con firma de JSON


curl -X PUT -d @masa.txt http://167.172.58.213:30571/masa.txt -vv #Si el metodo PUT esta habilitado subir archivo

#We first create a file named test.txt. The "@" symbol is used by cURL to read the file and send it's contents as the data. As we can see, the file was uploaded successfully and retrieved later.

 curl -X DELETE http://example.com/test.txt -vv 
```

<h2> Fuzzing </h2>

```bash
ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ # Basic Scan 
``` 

```bash
ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ # Basic Scan 
``` 

<h3> Extenciones </h3>

<p> Deacuerdo al tipo de servidor se podrian intuir extenciones por ejemplo si es apache, entonces puede ser .php, o si es IIS, entonces podría ser .asp o .aspx.</p>

```bash
ffuf -w /opt/useful/SecLists/Discovery/Web-Content/web-extensions.txt:FUZZ -u http://SERVER_IP:PORT/indexFUZZ #Buscamos la extencion de index 
```

```bash 
ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ -recursion -recursion-depth 1 -e .php -v #Escaneo recursivo con extencion php podemos poner las extenciones que queramos ejemplo -e .php,.html.js etc!
```
<h2> Virtual hosting Fuzzing </h2>

<p> Cuando ingresamos a una direccion IP se revisa primero el archivo /etc/hosts/ si no se encuentra ahi como resolver el dominio se consultan DNS publicos como el de google es por eso que cuando encontramos un dominio se agrega al /etc/hosts </p>

<h3> Subdomains </h2>

```bash
ffuf -w /opt/useful/SecLists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u https://FUZZ.paginapricipal.com/ #Basico para buscar subdominios
```

```bash
ffuf -w /opt/useful/SecLists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u https://FUZZ.paginapricipal.com/ #Basico para buscar subdominios
```

<h3>V Host </h3>

<p> La diferencia clave entre VHosts y subdominios es que un VHost es básicamente un 'subdominio' servido en el mismo servidor y tiene la misma IP, de modo que una sola IP podría servir a dos o más sitios web diferentes.
Una vez más, si usamos el fuzzing de subdominios, solo podríamos identificar subdominios públicos, pero no identificaremos ningún subdominio que no sea público.
</p>

```bash
ffuf -w /opt/useful/SecLists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u http://academy.htb:PORT/ -H 'Host: FUZZ.academy.htb'#Para escanear en busca de VHosts, sin agregar manualmente la lista de palabras completa a nuestro / etc / hosts, estaremos fuzzeando los encabezados HTTP, específicamente el encabezado Host :. Para hacer eso, podemos usar la bandera -H para especificar un encabezado y usaremos la palabra clave FUZZ dentro de él.
```

<h2> Fuzzeo de Parametros POST y GET </h2>

```bash
ffuf -w /opt/useful/SecLists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u http://sub.maindomain.local:PORT/users/admin.php?FUZZ=key -fs #fs sirve para filtrar la respuesta en base a su tamaño
```
<p> Recuerda que tienes que encontrar parametros validos</p>

```bash
 ffuf -w /opt/useful/SecLists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u http://sub.maindomain.local:PORT/users/admin.php -X POST -d 'FUZZ=key' -H 'Content-Type: application/x-www-form-urlencoded' -fs 793 # para encontrar un parametro valido de POST 
 ```
 <p> Despues buscar un valor </p>
 
 ```bash
ffuf -w idslist.txt:FUZZ  -u http://sub.maindomain.local:PORT/users/admin.php  -X POST -d 'id=FUZZ' -H 'Content-Type: application/x-www-form-urlencoded' -fs # para fuzzear un valor en un parametro valido 
 ```
 
<h3> HTTP VS HTTPS SSL y TLS </h3>

<p> Aunque es HTTP en su base, HTTPS utiliza los puertos 443 y 8443 en lugar del puerto estándar 80. Esta es una forma sencilla para que el cliente le indique al servidor que desea establecer una conexión segura. Veamos una salida de tráfico HTTPS y veamos cómo funciona un protocolo de enlace TLS durante un minuto.</p>}
<h3> URL Encode </h3>

<p> It is essential to ensure that our request data is URL-encoded and our request headers are correctly set. Otherwise, we may get a server error in the response. This is why encoding and decoding data becomes essential as we modify and repeat web requests. Some of the key characters we need to encode are:</p>

<p>Spaces: May indicate the end of request data if not encoded</p>
<p>&: Otherwise interpreted as a parameter delimiter            </p>
<p>#: Otherwise interpreted as a fragment identifier            </p>

<h3> The following are some of the other types of encoders </h3>

<p>HTML   </p> 
<p>Unicode</p>
<p>Base64   </p> 
<p>ASCII hex</p> 

<h2>  Type of Headers </h2>

<h3> General Headers </h3>

```bash
curl -I -X GET https://www.example.com


Date: Sun, 06 Aug 2020 08:49:37 GMT
Connection: keep-alive

```


<h3> Entity Headers </h3> 


```bash
curl -I -X GET https://www.example.com


Content-Length: 26012
Content-Type: text/html; charset=ISO-8859-4
Content-Encoding: gzip
```

<h3> Request Headers </h3>

```bash

curl -I -X GET https://www.inlanefreight.com

Host: www.inlanefreight.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/605.1.15 (KHTML, like Gecko)
Cookie: cookie1=298zf09hf012fh2; cookie2=u32t4o3tb3gg4
Accept: text/plain
Referer: https://www.hackthebox.eu/
Authorization: BASIC cGFzc3dvcmQK

```


<h3> Response Headers </h3> 


```bash 
curl -I -X GET https://www.example.com


Server: Apache/2.2.14 (Win32)
Set-Cookie: name1=value1,name2=value2; Expires=Wed, 09 Jun 2021 10:18:14 GMT
WWW-Authenticate: BASIC realm="localhost"

```

<h3> Security Headers </h3>

```bash
 curl -I -X GET https://www.example.com


Content-Security-Policy: script-src 'self'
Strict-Transport-Security: max-age=31536000
Referrer-Policy: origin

```




<h3> Response Codes </h3>


<p> The server uses the HTTP status codes to tell the client whether the request was successfully processed. An HTTP server can return five types of response codes: </p> 



<p> Type    Description</p> 

<ul>
<li>1xx Usually provides information and continues processing the request. </li>                                                                                             
<li>2xx Positive response codes returned when a request succeeds.  </li>                                                         
<li>3xx Returned when the server redirects the client.  </li>
<li>4xx This class of codes signifies improper requests from the client. For example, requesting a resource that doesn't exist or requesting a bad format.</li>
<li>5xx Returned when there is some problem with the HTTP server itself.</li>
</ul> 


<h3>  Common HTTP response codes </h3> 

<p>200 OK  Returned on a successful request, and the response usually contains the requested resource.
302 Found   This code redirects the client to another URL. For example, redirecting the user to their dashboard after a successful login.

400 Bad Request Usually returned on encountering malformed requests such as requests with missing line terminators.
403 Forbidden   This code signifies that the client doesn't have appropriate access to the resource. It can also be returned when the server detects malicious input from the user.


404 Not Found   Returned when the client requests a resource that doesn't exist on the server.
500 Internal Server Error   As the name describes, this code is returned when the server cannot process the request. </p>



<h3> Content Delivery Network </h3>

<p>
Eso es precisamente lo que hacen los CDN (Content Delivery Network o Content Distribution Network), que no son más que redes de servidores distribuidos geográficamente en los que residen aplicaciones, servicios o datos a los que los usuarios acceden remotamente. 
Ej: CloudFlare

En redes de computadoras, un proxy inverso es un tipo de servidor proxy que recupera recursos en nombre de un cliente desde uno o más servidores. Estos recursos se devuelven al cliente como si se originaran en el propio servidor Web.1​ Contrariamente a un proxy forward, que es un intermediario para que sus clientes asociados se pongan en contacto con cualquier servidor, un proxy inverso es un intermediario para que sus servidores asociados sean contactados por cualquier cliente.

Muy a menudo, los servidores web populares utilizan funcionalidad de proxy inverso, protegiendo los framework de aplicación de las debilidades de seguridad de HTTP. 

Asi, Cloudflare actúa como intermediaria entre el cliente y el servidor, usando unos sistemas llamados proxies reversos (reverse proxies) para crear copias espejo y cachés de sitios web. Eso permite distribuir las copias y que estén accesibles de forma rápida y segura a los clientes. 
</p>

<h3> Query strings </h3>

<p>
Se separan por & y comienzan con ? por ejemplo:

http://209.97.132.64:30193/flag.php?num1=668&num2=669
</p>

<h3> Protocolo WebDAV </h3>

<p>El protocolo WebDAV (Web-based Distributed Authoring and Versioning) está desarrollado por la IETF, es un protocolo que se encarga de permitirnos de forma sencilla guardar, editar, copiar, mover y compartir archivos desde servidores web. Gracias a este protocolo, podremos trabajar con archivos directamente en un servidor web, como si de un servidor Samba o FTP se tratara.</p>

